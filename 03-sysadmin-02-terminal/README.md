# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

	>cd - это builtin (встроенная в оболочку команда). Отличия внутренних от внешних команд в том, что они выполняются быстрее, так как не нужно искать путь для исполнения команды, она уже встрена в оболочку, а также не создается никаких новых процессов для выполнения встроенной команды. 
Ранее существовала команда chdir, которая делала тоже самое, но была внешней программой. Когда впервые был введен системный вызов fork и выпущено обновление с ним, команда chdir перестала корректно работать. В старой системе chdir выполнялась через один уникальный процесс и работала корректно. Но в обновленной версии уже присутствовал системный вызов fork. Fork создает новое адресное пространство, которое полностью идентично адресному пространству основного процесса. После выполнения этого системного вызова мы получаем два абсолютно одинаковых процесса - основной и порожденный. В обновленной версии в адресном пространстве, порожденном с помощью fork, выполнялась команда chdir, она корректно изменяла каталог процесса внутри этого вновь созданного пространства, прожденного с помощью fork. Потом порожденный процесс завершался. Но это изменение не оказывало никакого влияния на родительский процесс, из которого был запущен fork, и директория в родительском процессе не менялась, что не имело никакого эффекта. Поэтому команду cd сделали встроенной в оболочку, чтобы при выполнении не создавалось новых процессов.

	>Что такое fork и exec читала тут:
https://www.opennet.ru/docs/RUS/lnx_process/process2.html

	>Про сбой работы chdir после создания fork читала цитату из книги "The Evolution of the Unix Time-sharing System Dennis" M. Ritchie https://www.bell-labs.com/usr/dmr/www/hist.html:

	>"Although the multiple-process idea slipped in very easily indeed, there were some aftereffects that weren't anticipated. The most memorable of these became evident soon after the new system came up and apparently worked. In the midst of our jubilation, it was discovered that the chdir (change current directory) command had stopped working. There was much reading of code and anxious introspection about how the addition of fork could have broken the chdir call. Finally the truth dawned: in the old system chdir was an ordinary command; it adjusted the current directory of the (unique) process attached to the terminal. Under the new system, the chdir command correctly changed the current directory of the process created to execute it, but this process promptly terminated and had no effect whatsoever on its parent shell! It was necessary to make chdir a special command, executed internally within the shell. It turns out that several command-like functions have the same property, for example login."

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

	>grep -c <some_string> <some_file>

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
	>systemd
4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

	>ls 2> /dev/pts/1 , где 1 - номер териманала, на который нужно перенаправить вывод. я перенаправляла с нулевого терминала на первый.  
	Можно ввести ls root 2> /dev/pts/1, чтобы проверить.

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

	>Например так:
sort testfile.c 1> newfile
Но в этом случае команда sort итак по умолчанию на stdin ждет имя файла(нам для этого не нужно делать перенаправление). Поэтому мы просто в данном случае перенаправляем вывод этой команды в "newfile".

6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
	> У меня не получилось. При попытке выполнить такую команду "sudo ls > /dev/tty1" появляется ошибка permission denied. Если захожу под рутом, то команда выполняется, но возможности посмотреть ее вывод нет, так как для этого нужно выходить из графической оболочки в TTY.

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

	> Команда "bash 5>&1" создаст еще один фаловый дескриптор(под номером пять) и то, что было отправлено в этот файловый дескриптор будет отправлено теперь в файловый дискриптор 1, то есть на stdout.
Проверить, что файловый дескриптор на самом деле был создан данной командной можно используя следующую:

		lsof -a -p $$ -d 1,2,3,5

	> При вводе echo "netology > /proc/$$/fd/5" на терминале появляется такой вывод:

		bash: /proc/1288/fd/5: No such file or directory

	>Чтобы команда работала корректно, мы можем создадать фаловый дескриптор под номером 5 и направить в него stdout тестового файла, используя такую команду:

	vagrant@vagrant:~$exec 5> testfile.c

	>После этого введем изначальную команду:

	vagrant@vagrant:~$echo "netology > /proc/$$/fd/5"

	>И в файл testfile.c запишется строчка "netology"

	vagrant@vagrant:~$ cat testfile.c
	netology

	>Если не создать файловый дескриптор под номером 5, то
сможем пользоваться только стандартными дескрипторами и использовать такую запись:
echo netology > /proc/self/fd/2 (где 2 - дескриптор файлового процесса, можно использовать также 0 и 1)

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

	>Например, мы переносим файл в несуществующую папку командной mv. Терминал, конечно, выдаст ошибку. И в терминале при выводе ошибки мы хотим заменить все буквы 'r' на буквы 'o' командной 'tr'. Если мы через pipe напишем такие команды, то ничего не получится:

	mv 01-git-04-tools /trtr/df | tr r o

	>В терминале будет только корректный изначальный вывод ошибки и буквы через команды 'tr' не поменяются. Так как через pipe по умолчанию был передан stdout команды 'mv', который ничего в себе не содержал и поэтому буквы 'r' на 'o' там поменять невозможно. На экране будет неизмененный вывод ошибки:

	mv: rename 01-git-04-tools to /trtr/df: No such file or directory

	>Но мы можем перенаправить поток stderr команды 'mv' в stdin команды 'tr' таким образом:

	mv 01-git-04-tools /trtr/df 3>&1 1>&2 2>&3 | tr r o
И тогда в терминале будет вывод ошибки, где все буквы 'r' поменялись на буквы 'o':

	mv: oename 01-git-04-tools to /toto/df: No such file oo dioectooy
	> Таким образом, мы в качестве входного потока для pipe использовали stderr команды 'mv', не потеряв при этом отображение stdout команды 'tr' на pty.


9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

	>Команда env показывает аналогичный по содержанию вывод, только каждую переменную с новой строчки
10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
	>proc - папка(файловая система), из которой пользователь может получить инормацию о состоянии компьютера, системы, ядра. В папке proc есть много директорий вида /proc/[PID]/, где PID -  это номер запущенного процесса. В самой этой папке содержится вся информация о данном процессе. Если процесс заканчивается, то директория удаляется из системы.

	>/proc/[PID]/cmdline - здесь хранится команда, которой был запущен процесс с данным pid, а также переданные этой команде параметры;

	>/proc/[PID]/exe - символическая ссылка на исполняемый файл, который инициировал запуск процесса с данным pid;
11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
	>sse4_2
12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.

	>По умолчанию при выполнении команды на удаленной машине с использованием ssh для удаленного сеанса не выделяется TTY.

	>Если мы добавим к команде 'ssh' опцию 't', то tty выделится. Опция -t отключает псевдотерминальное распределение.

		ssh -t localhost 'tty'

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

		reptyr PID


14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

	> В первой команде перенаправление обрабатывается до выполнения команды. В команде `sudo echo string > /root/new_file` мы делаем снчала перенаправление и пытаемся зайти в файл /root/new_file в тот момент, когда мы еще не под пользователем root. Поэтому мы не можем ничего записать в этот файл, у нас недостаточно прав. До выполнения самой команды `sudo echo` мы еще даже не дошли.

	>Во второй команде `echo string | sudo tee /root/new_file` мы сначала выполняем команду `echo`, затем в файл заходим через `sudo tee`, поэтому записать строчку в файл у нас получается. Здесь мы используем tee для того, чтобы перенаправить данные в файл.
